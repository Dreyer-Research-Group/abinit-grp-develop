!{\src2tex{textfont=tt}}
!!****m* ABINIT/m_multibinit_manager
!! NAME
!! m_multibinit_manager
!!
!! FUNCTION
!! This module contains the manager type, which is a thin layer above ALL 
!! TODO: the structure of this is yet to be discussed
!!
!!
!! Datatypes:
!!
!! * mb_manager_t
!!
!! Subroutines:
!! TODO: add this when F2003 doc style is determined.
!!
!!
!! COPYRIGHT
!! Copyright (C) 2001-2019 ABINIT group (hexu)
!! This file is distributed under the terms of the
!! GNU General Public License, see ~abinit/COPYING
!! or http://www.gnu.org/copyleft/gpl.txt .
!! For the initials of contributors, see ~abinit/doc/developers/contributors.txt .
!!
!! SOURCE


#if defined HAVE_CONFIG_H
#include "config.h"
#endif

#include "abi_common.h"

module m_multibinit_manager
  use defs_basis
  use m_abicore
  use m_errors
  use m_xmpi

  use m_init10, only: init10
  use m_mathfuncs, only: diag
  use m_multibinit_dataset, only: multibinit_dtset_type, invars10, &
       outvars_multibinit, multibinit_dtset_free
  use m_unitcell, only : unitcell_t
  use m_supercell_maker, only: supercell_maker_t
  use m_multibinit_supercell, only: mb_supercell_t
  use m_primitive_potential_list, only: primitive_potential_list_t
  use m_primitive_potential, only: primitive_potential_t
  use m_spin_primitive_potential, only: spin_primitive_potential_t
  use m_abstract_potential, only: abstract_potential_t
  use m_potential_list, only: potential_list_t
  use m_abstract_mover, only: abstract_mover_t
  use m_lattice_effpot, only : lattice_effpot_t
  use m_spin_potential, only : spin_potential_t
  use m_lattice_mover, only : lattice_mover_t
  use m_spin_mover, only : spin_mover_t
  use m_mpi_scheduler, only: init_mpi_info
  ! TODO : should these be moved into spin mover?
  use m_spin_ncfile, only: spin_ncfile_t

  use m_spin_lattice_coupling_effpot, only : spin_lattice_coupling_effpot_t
  implicit none
  private

  !!***

  !-------------------------------------------------------------------!
  ! Multibinit manager
  !-------------------------------------------------------------------!
  type, public :: mb_manager_t
     character(len=fnlen) :: filenames(17)
     type(multibinit_dtset_type), pointer :: params
     type(supercell_maker_t) :: sc_maker
     type(unitcell_t) :: unitcell
     type(mb_supercell_t) :: supercell
     type(primitive_potential_list_t) :: prim_pots
     type(potential_list_t) :: pots

     type(lattice_mover_t) :: lattice_mover
     type(spin_mover_t) :: spin_mover
     ! type(lwf_mover_t) :: lwf_mover
     type(spin_ncfile_t) :: spin_ncfile

     ! TODO: this is temporary. Remove after moving to multibinit_main2
     logical :: use_external_params=.True.
   contains
     procedure :: initialize
     procedure :: finalize
     procedure :: read_params    ! parse input file
     procedure :: prepare_params ! process the parameters. e.g. convert unit, set some flags, etc.
     procedure :: read_potentials ! read primitve cell and potential
     procedure :: fill_supercell
     procedure :: set_movers
     procedure :: run_spin_dynamics
     procedure :: run_MvT
     procedure :: run
     procedure :: run_all
  end type mb_manager_t

contains
  !-------------------------------------------------------------------!
  ! initialize
  !-------------------------------------------------------------------!
  subroutine initialize(self, filenames,params)
    class(mb_manager_t), intent(inout) :: self
    character(len=fnlen), intent(inout) :: filenames(17)
    type(multibinit_dtset_type), target, optional, intent(in) :: params
    integer:: ierr
    integer :: master, my_rank, comm, nproc, ierr
    logical :: iam_master
    call init_mpi_info(master, iam_master, my_rank, comm, nproc) 


    !TODO: remove params as argument. It is here because the params are read
    ! in the multibinit_main function. Once we use multibinit_main2, remove it.
    if (present(params)) then
       self%params=>params
    else
       self%use_external_params=.False.
       allocate(self%params)
       call self%read_params()
    endif
    self%filenames=filenames
    call xmpi_bcast(self%filenames, master, comm, ierr)
    call self%prepare_params()
    ! read potentials from
  end subroutine initialize


  !-------------------------------------------------------------------!
  ! Finalize
  !-------------------------------------------------------------------!
  subroutine finalize(self)
    class(mb_manager_t), intent(inout) :: self
    call self%sc_maker%finalize()
    call self%unitcell%finalize()
    call self%supercell%finalize()
    call self%prim_pots%finalize()
    call self%pots%finalize()
    call self%spin_mover%finalize()
    call self%lattice_mover%finalize()
    if(.not. self%use_external_params) then
       call multibinit_dtset_free(self%params)
       ! TODO: Intel compilers complains but it should not. Uncomment when know why.
       !deallocate(self%params)
    endif
    nullify(self%params)
    !call self%lwf_mover%finalize()
  end subroutine finalize

  !-------------------------------------------------------------------!
  ! read_params: read parameters from input file
  !-------------------------------------------------------------------!
  subroutine read_params(self)
    use m_fstrings,   only : replace, inupper
    use m_parser, only: instrng
    use m_dtset,      only : chkvars
    use m_effective_potential_file
    use m_effective_potential
    class(mb_manager_t), intent(inout) :: self
    character(len=500) :: message
    integer :: lenstr
    integer :: natom,nph1l,nrpt,ntypat
    integer :: option
    character(len=strlen) :: string
    integer :: master, my_rank, comm, nproc, ierr
    logical :: iam_master
    call init_mpi_info(master, iam_master, my_rank, comm, nproc) 

    !To automate a maximum calculation, multibinit reads the number of atoms
    !in the file (ddb or xml). If DDB file is present in input, the ifc calculation
    !will be initilaze array to the maximum of atoms (natifc=natom,atifc=1,natom...) in invars10
    if(iam_master) then
       write(message, '(6a)' )' Read the information in the reference structure in ',ch10,&
            & '-',trim(self%filenames(3)),ch10,' to initialize the multibinit input'
       call wrtout(ab_out,message,'COLL')
       call wrtout(std_out,message,'COLL')
    end if

    call effective_potential_file_getDimSystem(self%filenames(3),natom,ntypat,nph1l,nrpt)

    !Read the input file, and store the information in a long string of characters
    !strlen from defs_basis module
    option=1
    if (iam_master) then
       call instrng (self%filenames(1),lenstr,option,strlen,string)
       !To make case-insensitive, map characters to upper case:
       call inupper(string(1:lenstr))

       !Check whether the string only contains valid keywords
       call chkvars(string)

    end if

    call xmpi_bcast(string,master, comm, ierr)
    call xmpi_bcast(lenstr,master, comm, ierr)

    !Read the input file
    call invars10(self%params,lenstr,natom,string)

    if (iam_master) then
       !  Echo the inputs to console and main output file
       call outvars_multibinit(self%params,std_out)
       call outvars_multibinit(self%params,ab_out)
    end if
  end subroutine read_params

  !-------------------------------------------------------------------!
  ! prepare_params: after read, something has to be done:
  ! e.g. unit conversion
  !-------------------------------------------------------------------!
  subroutine prepare_params(self)
    class(mb_manager_t), intent(inout) :: self
    ! Kelvin to Hartree (In input file, the spin temperature is in K.
    ! convert to a.u.)
    self%params%spin_temperature = self%params%spin_temperature/Ha_K
    self%params%spin_temperature_start=self%params%spin_temperature_start/Ha_K
    self%params%spin_temperature_end=self%params%spin_temperature_end/Ha_K
  end subroutine prepare_params


  !-------------------------------------------------------------------!
  ! Read potentials from file, if needed by dynamics
  !-------------------------------------------------------------------!
  subroutine read_potentials(self)
    class(mb_manager_t), intent(inout) :: self
    type(spin_primitive_potential_t), pointer :: spin_pot

    integer :: master, my_rank, comm, nproc, ierr
    logical :: iam_master
    call init_mpi_info(master, iam_master, my_rank, comm, nproc) 



    !class(primitive_potential_t), pointer :: t
    call self%unitcell%initialize()
    ! latt : TODO

    ! spin
    call xmpi_bcast(self%params%spin_dynamics, master, comm, ierr)
    if(self%params%spin_dynamics>0) then
       allocate(spin_pot)
       call spin_pot%initialize(self%unitcell)
       call spin_pot%load_from_files(self%params, self%filenames)
       call self%prim_pots%append(spin_pot)
    end if
    if(self%params%dynamics>0) then
       !TODO: LATT
    endif

    !LWF : TODO
  end subroutine read_potentials

  !-------------------------------------------------------------------!
  ! fill supercell. Both primitive cell and potential
  !-------------------------------------------------------------------!
  subroutine fill_supercell(self)
    class(mb_manager_t), target, intent(inout) :: self
    !class(abstract_potential_t), pointer :: q
    ! unitcell
    call self%unitcell%fill_supercell(self%sc_maker, self%supercell)
    call self%pots%initialize()
    call self%pots%set_supercell(self%supercell)
    call self%prim_pots%fill_supercell_list(self%sc_maker,self%pots)
    call self%pots%set_supercell(self%supercell)
  end subroutine fill_supercell

  !-------------------------------------------------------------------!
  ! Fit lattic model
  !-------------------------------------------------------------------!
  subroutine fit_lattice_model(self)
    class(mb_manager_t), intent(inout) :: self
    !TODO:
  end subroutine fit_lattice_model


  !-------------------------------------------------------------------!
  ! initialize movers needed.
  !-------------------------------------------------------------------!
  subroutine set_movers(self)
    class(mb_manager_t), intent(inout) :: self
    if (self%params%spin_dynamics>0) then
       call self%spin_mover%initialize(self%params, supercell=self%supercell)
    end if

    if (self%params%dynamics>0) then
       call self%lattice_mover%initialize(self%params, self%filenames)
    end if

    ! TODO: LWF MOVER
  end subroutine set_movers


  !-------------------------------------------------------------------!
  ! Run dynamics
  !-------------------------------------------------------------------!
  subroutine run_spin_dynamics(self)
    class(mb_manager_t), intent(inout) :: self
    call self%prim_pots%initialize()
    call self%read_potentials()

    call self%sc_maker%initialize(diag(self%params%ncell))

    call self%fill_supercell()

    call self%set_movers()
    call self%spin_mover%run_time(self%pots)
  end subroutine run_spin_dynamics

  subroutine run_MvT(self)
    class(mb_manager_t), intent(inout) :: self
    call self%prim_pots%initialize()
    call self%sc_maker%initialize(diag(self%params%ncell))
    ! read params
    call self%read_potentials()
    call self%fill_supercell()
    call self%set_movers()
    call self%spin_mover%run_MvT(self%pots, self%filenames(2))
  end subroutine run_MvT

  !-------------------------------------------------------------------!
  ! Run all jobs
  !-------------------------------------------------------------------!
  subroutine run(self)
    class(mb_manager_t), intent(inout) :: self
    ! if ... fit lattice model
    ! if ... fit lwf model
    ! if ... run dynamics...
    if(self%params%spin_dynamics>0) then
       if (self%params%spin_var_temperature==0) then
          call self%run_spin_dynamics()
       elseif (self%params%spin_var_temperature==1) then
          call self%run_MvT()
       end if
    end if
    ! if ...
  end subroutine run



  !-------------------------------------------------------------------!
  !run_all: THE function which does everything
  !         from the very begining to end.
  !-------------------------------------------------------------------!
  subroutine run_all(self, filenames, params)
    class(mb_manager_t), intent(inout) :: self
    character(len=fnlen), intent(inout) :: filenames(17)
    type(multibinit_dtset_type), optional, intent(in) :: params
    call self%initialize(filenames, params=params)
    call self%run()
    call self%finalize()
  end subroutine run_all

end module m_multibinit_manager
