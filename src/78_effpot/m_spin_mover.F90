!{\src2tex{textfont=tt}}
!!****m* ABINIT/m_spin_mover
!! NAME
!! m_spin_mover
!!
!! FUNCTION
!! This module contains the spin mover, which controls how the spin 
!!
!!
!! Datatypes:
!!
!! * spin_mover_t
!!
!! Subroutines:
!!
!! * spin_mover_t_initialize
!! * spin_mover_t_run_one_step
!! * spin_mover_t_run_time
!! * TODO: update this when F2003 documentation format decided.
!!
!!
!! COPYRIGHT
!! Copyright (C) 2001-2019 ABINIT group (hexu)
!! This file is distributed under the terms of the
!! GNU General Public License, see ~abinit/COPYING
!! or http://www.gnu.org/copyleft/gpl.txt .
!! For the initials of contributors, see ~abinit/doc/developers/contributors.txt .
!!
!! SOURCE


#if defined HAVE_CONFIG_H
#include "config.h"
#endif
#include "abi_common.h"
module m_spin_mover
  use defs_basis
  use m_errors
  use m_abicore
  use m_xmpi
  use m_io_tools, only : get_unit, open_file, close_unit
  use m_multibinit_global
  use m_mpi_scheduler, only: mpi_scheduler_t
  use m_mathfuncs, only : cross
  use m_spin_observables , only : spin_observable_t
  use m_spin_potential, only:  spin_potential_t
  use m_spin_hist, only: spin_hist_t
  use m_spin_ncfile, only: spin_ncfile_t
  use m_spin_observables, only: spin_observable_t
  use m_multibinit_dataset, only: multibinit_dtset_type
  use m_multibinit_supercell, only: mb_supercell_t
  use m_random_xoroshiro128plus, only: set_seed, rand_normal_array, rng_t
  use m_abstract_potential, only: abstract_potential_t
  use m_abstract_mover, only: abstract_mover_t
  use m_spin_mc_mover, only : spin_mc_t
  implicit none
  private
  !!***


  !!****t* m_spin_mover/spin_mover_t
  !! NAME
  !! spin_mover_t
  !!
  !! FUNCTION
  !! this type contains the parameters for the spin mover.
  !!
  !! It contains:
  !! dt: time step
  !! total_time
  !! temperature.
  !! nspin number of magnetic atoms
  !! SOURCE


  type, public, extends(abstract_mover_t) :: spin_mover_t
     integer :: nspin, method
     real(dp) :: dt, total_time, temperature, pre_time
     real(dp), allocatable :: gyro_ratio(:), damping(:), gamma_L(:), H_lang_coeff(:), ms(:), Stmp(:,:)
     real(dp), allocatable :: Heff_tmp(:,:), Htmp(:,:), Hrotate(:,:), H_lang(:,:), buffer(:,:)
     type(rng_t) :: rng
     type(spin_hist_t) :: hist
     logical :: gamma_l_calculated
     type(spin_mc_t) :: spin_mc
     type(mpi_scheduler_t) :: mps
     type(spin_observable_t) :: spin_ob
     type(spin_ncfile_t) :: spin_ncfile
     type(multibinit_dtset_type), pointer :: params
   CONTAINS
     procedure :: initialize
     procedure :: finalize
     procedure :: set_initial_state
     procedure, private :: run_one_step_DM => spin_mover_t_run_one_step_DM
     procedure, private :: run_one_step_HeunP => spin_mover_t_run_one_step_HeunP
     procedure, private :: run_one_step_MC=> spin_mover_t_run_one_step_MC
     procedure :: run_one_step => spin_mover_t_run_one_step
     procedure :: run_time => spin_mover_t_run_time
     procedure :: run_MvT
     procedure :: set_temperature
     procedure :: prepare_ncfile
     procedure, private ::get_Langevin_Heff
     procedure :: current_spin
  end type spin_mover_t
  !!***

contains

  !!****f* m_spin_mover/initialize
  !!
  !! NAME
  !!  initialize
  !!
  !! FUNCTION
  !!  initialize the spin mover
  !!
  !! INPUTS
  !!
  !! OUTPUT
  !!
  !! NOTES
  !!
  !! PARENTS
  !!
  !! CHILDREN
  !!
  !! SOURCE
  subroutine initialize(self, params, supercell)
    class(spin_mover_t), intent(inout) :: self
    type(multibinit_dtset_type), target :: params
    type(mb_supercell_t), target :: supercell
    !real(dp):: damping(self%supercell%nspin)
    integer :: i, nspin
    self%params=>params
    self%supercell=>supercell
    if (iam_master) then
       nspin=supercell%nspin
       self%nspin=nspin
       self%dt= params%spin_dt
       self%pre_time= params%spin_ntime_pre * self%dt
       self%total_time= params%spin_ntime * self%dt
       self%temperature=params%spin_temperature
       if(params%spin_dynamics>=0) then
          self%method=params%spin_dynamics
       endif
    end if
    if(params%spin_dynamics==3) then ! Monte carlo
       call self%spin_mc%initialize(nspin=nspin, angle=1.0_dp, temperature=params%spin_temperature)
    end if
    call xmpi_bcast(self%nspin, master, comm, ierr)
    call xmpi_bcast(self%dt, master, comm, ierr)
    call xmpi_bcast(self%pre_time, master, comm, ierr)
    call xmpi_bcast(self%total_time, master, comm, ierr)
    call xmpi_bcast(self%temperature, master, comm, ierr)
    call xmpi_bcast(self%method, master, comm, ierr)
    call set_seed(self%rng, [111111_dp, 2_dp])
    if(my_rank>0) then
       do i =1,my_rank
          call self%rng%jump()
       end do
    end if

    ABI_ALLOCATE(self%ms, (self%nspin) )
    ABI_ALLOCATE(self%gyro_ratio, (self%nspin) )
    ABI_ALLOCATE(self%damping, (self%nspin) )
    ABI_ALLOCATE(self%gamma_l, (self%nspin) )
    ABI_ALLOCATE(self%H_lang_coeff, (self%nspin) )

    ABI_ALLOCATE(self%Heff_tmp, (3,self%nspin) )
    ABI_ALLOCATE(self%Htmp, (3,self%nspin) )
    ABI_ALLOCATE(self%Hrotate, (3,self%nspin) )
    ABI_ALLOCATE(self%Stmp, (3,self%nspin) )
    ABI_ALLOCATE(self%buffer, (3,self%nspin) )
    ABI_ALLOCATE(self%H_lang, (3,self%nspin) )

    self%gamma_l_calculated=.False.
    call self%mps%initialize(nspin, comm)


    call xmpi_bcast(params%spin_damping, master, comm, ierr)

    if (iam_master) then
       if (params%spin_damping >=0) then
          self%damping(:)= params%spin_damping
       else
          self%damping(:)=supercell%gilbert_damping(:)
       end if

       self%gyro_ratio(:)=supercell%gyro_ratio(:)
       self%ms(:)=supercell%ms(:)
    endif

    call xmpi_bcast(self%damping, master, comm, ierr)
    call xmpi_bcast(self%gyro_ratio, master, comm, ierr)
    call xmpi_bcast(self%ms, master, comm, ierr)
    call self%set_temperature(temperature=params%spin_temperature)

    ! Hist and set initial spin state
    if(iam_master) then
       call self%hist%initialize(nspin=self%nspin, &
            &   mxhist=3, has_latt=.False.)
       call self%hist%set_params(spin_nctime=params%spin_nctime, &
            &     spin_temperature=params%spin_temperature)
    endif

    call self%set_initial_state(mode=params%spin_init_state)

    ! observable
    if(iam_master) then
       call self%spin_ob%initialize(self%supercell, params)
    endif

  end subroutine initialize
  !!***

  !-------------------------------------------------------------------!
  !set_ncfile_name :
  !-------------------------------------------------------------------!
  subroutine set_ncfile_name(self, params, fname)
    class(spin_mover_t), intent(inout) :: self
    type(multibinit_dtset_type) :: params
    character(len=fnlen), intent(in) :: fname
    call self%prepare_ncfile(params, trim(fname)//'_spinhist.nc')
    call self%spin_ncfile%write_one_step(self%hist)
  end subroutine set_ncfile_name


  !-------------------------------------------------------------------!
  !set_initial_state:
  !-------------------------------------------------------------------!
  subroutine set_initial_state(self, mode)
    class(spin_mover_t), intent(inout) :: self
    integer, optional, intent(in) :: mode
    integer :: i, m
    real(dp) :: S(3, self%nspin)
    character(len=500) :: msg
    if(iam_master) then
       if (present(mode)) then
          m=mode
       else
          m=1
       end if
    if(m==2) then
       ! set all spin to z direction.
       S(1,:)=0.0d0
       S(2,:)=0.0d0
       S(3,:)=1.0d0
    else if (m==1) then
       ! randomize S using uniform random number
       write(msg,*) "Initial spin set to random value."
       call wrtout(ab_out,msg,'COLL')
       call wrtout(std_out,msg,'COLL')
       call random_number(S)
       S=S-0.5
       do i=1, self%nspin
          S(:,i)=S(:,i)/sqrt(sum(S(:, i)**2))
       end do
    else
       write(msg,*) "Error: Set initial spin: mode should be 2(FM) or 1 (random). Others are not yet implemented."
       call wrtout(ab_out,msg,'COLL')
       call wrtout(std_out,msg,'COLL')

    end if
    call self%hist%set_vars(S=S, Snorm=self%supercell%ms, &
         &  time=0.0_dp, ihist_latt=0, inc=.True.)
   endif
 end subroutine set_initial_state


 !-------------------------------------------------------------------!
 ! prepare_ncfile:
 !-------------------------------------------------------------------!
 subroutine prepare_ncfile(self,  params, fname)
   class(spin_mover_t), intent(inout) :: self
   type(multibinit_dtset_type) :: params
   character(len=*), intent(in) :: fname
   if(iam_master) then
      call self%spin_ncfile%initialize( trim(fname), params%spin_write_traj)
      call self%spin_ncfile%def_spindynamics_var(self%hist )
      call self%spin_ncfile%def_observable_var(self%spin_ob)
      !call spin_ncfile_t_write_primitive_cell(self%spin_ncfile, self%spin_primitive)
      call self%spin_ncfile%write_supercell(self%supercell)
      call self%spin_ncfile%write_parameters(params)
   endif
 end subroutine prepare_ncfile



  subroutine set_temperature(self, temperature)
    class(spin_mover_t), intent(inout) :: self
    real(dp), optional, intent(in) ::  temperature
    if(present(temperature)) self%temperature=temperature
    call xmpi_bcast(self%temperature, master, comm, ierr)
    if(self%method==3) then
       if(iam_master) self%spin_mc%temperature = temperature
       if(iam_master) self%spin_mc%beta=1.0_dp/temperature
       call xmpi_bcast(self%spin_mc%temperature, master, comm, ierr)
       call xmpi_bcast(self%spin_mc%beta, master, comm, ierr)
    end if
    self%gamma_l(:)= self%gyro_ratio(:)/(1.0_dp+ self%damping(:)**2)
    self%gamma_l_calculated=.True.
    self%H_lang_coeff(:)=sqrt(2.0*self%damping(:)* self%temperature &
         &  /(self%gyro_ratio(:)* self%dt *self%ms(:)))
  end subroutine set_temperature


  subroutine get_Langevin_Heff(self, H_lang)
    class(spin_mover_t), intent(inout) :: self
    real(dp), intent(inout):: H_lang(3,self%nspin)
    integer :: i
    if ( self%temperature .gt. 1d-7) then
       call rand_normal_array(self%rng, H_lang(:, self%mps%istart:self%mps%iend), 3*self%mps%ntask)
       do i = self%mps%istart, self%mps%iend
          H_lang(:,i)= H_lang(:,i) * self%H_lang_coeff(i)
       end do
    else
       H_lang(:,:)=0.0_dp
    end if
  end subroutine get_Langevin_Heff


  !!****f* m_spin_mover/spin_mover_t_run_one_step_HeunP
  !!
  !! NAME
  !!  spin_mover_t_run_one_step_HeunP
  !!
  !! FUNCTION
  !! run one spin step using HeunP method
  !!
  !! INPUTS
  !! effpot: abstract_potential_t type.
  !! S_in : input spin. (3*nspin)
  !!
  !! OUTPUT
  !! S_out: output spin (3*nspin)
  !! etot: energy (scalar)
  !!
  !! PARENTS
  !!
  !! CHILDREN
  !!
  !! SOURCE
  subroutine spin_mover_t_run_one_step_HeunP(self, effpot, S_in, S_out, etot, displacement, strain, lwf)
    !class (spin_mover_t), intent(inout):: self
    class(spin_mover_t), intent(inout):: self
    class(abstract_potential_t), intent(inout) :: effpot

    real(dp), optional, intent(inout):: displacement(:,:), &
         strain(:,:), lwf(:)
    real(dp), intent(inout) :: S_in(3,self%nspin)
    real(dp), intent(out) :: S_out(3,self%nspin), etot
    integer :: i
    real(dp) :: dSdt(3), Htmp(3), Ri(3)

    ! predict
    etot=0.0
    self%Heff_tmp(:,:)=0.0
    call effpot%calculate(displacement=displacement, strain=strain, lwf=lwf, spin=S_in, bfield=self%Heff_tmp, energy=etot)
    call xmpi_bcast(self%Heff_tmp, master, comm, ierr)
    call self%get_Langevin_Heff(self%H_lang)
    do i=self%mps%istart, self%mps%iend
       Htmp=self%Heff_tmp(:,i)+self%H_lang(:,i)
       Ri = cross(S_in(:,i),Htmp)
       dSdt = -self%gamma_L(i)*(Ri+self%damping(i)* cross(S_in(:,i), Ri))
       Ri=S_in(:,i)+dSdt*self%dt
       Ri=Ri/sqrt(Ri(1)*Ri(1)+Ri(2)*Ri(2)+Ri(3)*Ri(3))
       S_out(:,i)=Ri
    end do
    call self%mps%gatherv_dp2d(S_out, 3, buffer=self%buffer)
    call xmpi_bcast(S_out, master, comm, ierr)
    ! correction

    self%Htmp(:,:)=0.0
    etot=0.0
    call effpot%calculate(displacement=displacement, strain=strain, lwf=lwf,spin=S_out, bfield=self%Htmp, energy=etot)
    call xmpi_bcast(self%Htmp, master, comm, ierr)
    do i=self%mps%istart, self%mps%iend
       Htmp=(self%Heff_tmp(:,i)+self%Htmp(:,i))*0.5_dp+self%H_lang(:,i)
       Ri = cross(S_in(:,i),Htmp)
       dSdt = -self%gamma_L(i)*(Ri+self%damping(i)* cross(S_in(:,i), Ri))
       Ri=S_in(:,i)+dSdt*self%dt
       Ri=Ri/sqrt(Ri(1)*Ri(1)+Ri(2)*Ri(2)+Ri(3)*Ri(3))
       S_out(:,i)=Ri
    end do
    call self%mps%gatherv_dp2d(S_out, 3, buffer=self%buffer)
    call xmpi_bcast(S_out, master, comm, ierr)
  end subroutine spin_mover_t_run_one_step_HeunP
!!***

  pure function rotate_S_DM(S_in, Heff, dt) result(S_out)
    ! Depondt & Mertens method to rotate S_in
    real(dp), intent(in) :: S_in(3), Heff(3), dt
    real(dp) :: S_out(3)
    real(dp) :: B(3) , w, u, Bnorm, R(3,3), cosw, sinw
    Bnorm=sqrt(sum(Heff*Heff))
    B(:)=Heff(:)/Bnorm
    w=Bnorm*dt
    sinw=sin(w)
    cosw=sqrt(1.0_dp- sinw*sinw)
    u=1.0d0-cosw
    R(1,1)=B(1)*B(1)*u+cosw
    R(2,1)=B(1)*B(2)*u+B(3)*sinw
    R(3,1)=B(1)*B(3)*u-B(2)*sinw

    R(1,2)=B(1)*B(2)*u-B(3)*sinw
    R(2,2)=B(2)*B(2)*u+cosw
    R(3,2)=B(2)*B(3)*u+B(1)*sinw

    R(1,3)=B(1)*B(3)*u+B(2)*sinw
    R(2,3)=B(2)*B(3)*u-B(1)*sinw
    R(3,3)=B(3)*B(3)*u+cosw
    S_out=matmul(R, S_in)
  end function rotate_S_DM

  subroutine spin_mover_t_run_one_step_DM(self, effpot, S_in, S_out, etot, displacement, strain, lwf)
    ! Depondt & Mertens (2009) method, using a rotation matrix so length doesn't change.
    !class (spin_mover_t), intent(inout):: self
    class(spin_mover_t), intent(inout):: self
    class(abstract_potential_t), intent(inout) :: effpot
    real(dp), optional, intent(inout) :: displacement(:,:), strain(:,:), lwf(:)
    real(dp), intent(inout) :: S_in(3,self%nspin)
    real(dp), intent(out) :: S_out(3,self%nspin), etot
    real(dp) :: Htmp(3)
    integer :: i

    ! predict
    S_out(:,:)=0.0_dp
    etot=0.0
    self%Heff_tmp(:,:)=0.0_dp
    call effpot%calculate(displacement=displacement, strain=strain, lwf=lwf,spin=S_in, &
         bfield=self%Heff_tmp, energy=etot)
    call xmpi_bcast(self%Heff_tmp, master, comm, ierr)
    call self%get_Langevin_Heff(self%H_lang)
    do i=self%mps%istart, self%mps%iend
       Htmp=self%Heff_tmp(:,i)+self%H_lang(:,i)
       ! Note that there is no - , because dsdt =-cross (S, Hrotate) 
       self%Hrotate(:,i) = self%gamma_L(i) * (Htmp + self%damping(i)* cross(S_in(:,i), Htmp))
       S_out(:,i)= rotate_S_DM(S_in(:,i), self%Hrotate(:,i), self%dt)
    end do
    call self%mps%gatherv_dp2d(S_out, 3, self%buffer)
    call xmpi_bcast(S_out, master, comm, ierr)

    ! correction
    self%Htmp(:,:)=0.0_dp
    etot=0.0
    call effpot%calculate(displacement=displacement, strain=strain, lwf=lwf, spin=S_out, &
         bfield=self%Htmp, energy=etot)
    call xmpi_bcast(self%Htmp, master, comm, ierr)

    do i=self%mps%istart, self%mps%iend
       Htmp=(self%Heff_tmp(:,i)+self%Htmp(:,i))*0.5_dp + self%H_lang(:,i)
       self%Hrotate(:,i) = self%gamma_L(i) * (Htmp + self%damping(i)* cross(S_in(:,i), Htmp))
       S_out(:, i)= rotate_S_DM(S_in(:,i), self%Hrotate(:,i), self%dt)
    end do
    call self%mps%gatherv_dp2d(S_out, 3, self%buffer)
    call xmpi_bcast(S_out, master, comm, ierr)
  end subroutine spin_mover_t_run_one_step_DM

  subroutine spin_mover_t_run_one_step_MC(self, effpot, S_in, S_out, etot, displacement, strain,  lwf)
    class(spin_mover_t), intent(inout) :: self
    class(abstract_potential_t), intent(inout) :: effpot
    real(dp), optional, intent(inout) :: displacement(:, :), strain(:,:), lwf(:)
    real(dp), intent(inout) :: S_in(3,self%nspin)
    real(dp), intent(out) :: S_out(3,self%nspin), etot
    call self%spin_mc%run_MC(self%rng, effpot, S_in, S_out, etot)
  end subroutine spin_mover_t_run_one_step_MC

  subroutine spin_mover_t_run_one_step(self, effpot, displacement, strain, spin, lwf)
    class(spin_mover_t), intent(inout) :: self
    class(abstract_potential_t), intent(inout) :: effpot
    real(dp), optional, intent(inout) :: displacement(:,:), strain(:,:), spin(:,:), lwf(:)
    real(dp) :: S_out(3,self%nspin), etot
    if(present(spin)) MSG_ERROR("spin should not be input for spin mover.")
    if(iam_master) self%Stmp=self%hist%get_S()
    if(self%method==1) then
       call self%run_one_step_HeunP(effpot=effpot, S_in=self%Stmp, S_out=S_out, etot=etot, &
            displacement=displacement, strain=strain, lwf=lwf)
    else if (self%method==2) then
       call self%run_one_step_DM(effpot=effpot, S_in=self%Stmp, S_out=S_out, etot=etot,&
            displacement=displacement, strain=strain, lwf=lwf)
    else if (self%method==3) then
       if(present(displacement) .or. present(strain) .or. present(lwf)) then
          MSG_ERROR("Monte carlo not implemented for lattice and lwf yet.")
       endif
       call self%run_one_step_MC(effpot, self%Stmp, S_out, etot)
    end if
    ! do not inc until time is set to hist.
    if(iam_master) then
       call self%hist%set_vars( S=S_out, Snorm=effpot%supercell%ms, etot=etot, inc=.False.)
    end if
  end subroutine spin_mover_t_run_one_step

  !!****f* m_spin_mover/spin_mover_t_run_time
  !!
  !! NAME
  !!  spin_mover_t_run_time
  !!
  !! FUNCTION
  !! run all spin step
  !!
  !! INPUTS
  !!
  !! OUTPUT
  !!
  !! NOTES
  !!
  !!
  !! PARENTS
  !!
  !! CHILDREN
  !!
  !! SOURCE
  subroutine spin_mover_t_run_time(self, calculator, displacement, strain, spin, lwf)

    class(spin_mover_t), intent(inout):: self
    class(abstract_potential_t), intent(inout) :: calculator

    real(dp), optional, intent(inout) :: displacement(:,:), strain(:,:), lwf(:), spin(:,:)
    !type(spin_hist_t), intent(inout) :: hist
    !type(spin_ncfile_t), intent(inout) :: ncfile
    !type(spin_observable_t), intent(inout) :: ob
    !real(dp) ::  S(3, self%nspin)
    real(dp):: t
    integer :: counter, i, ii
    character(len=80) :: msg, msg_empty

    t=0.0
    counter=0
    if(iam_master) then
       msg_empty=ch10

       msg=repeat("=", 80)
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')
       write(msg, '(A20)') "Spin dynamic steps:"
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')
       msg=repeat("=", 80)
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')

       write(msg, "(A13, 4X, A13, 6X, A13, 4X, A13)")  "Iteration", "time(s)", "Avg_Mst/Ms", "ETOT(Ha/uc)"
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')

       msg=repeat("-", 80)
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')
    end if

    if (abs(self%pre_time) > 1e-30) then
       if (iam_master) then
          msg="Thermalization run:"
          call wrtout(std_out,msg,'COLL')
          call wrtout(ab_out, msg, 'COLL')
       end if

       do while(t<self%pre_time)
          counter=counter+1
          call self%run_one_step(effpot=calculator, displacement=displacement, strain=strain, lwf=lwf)
          if (iam_master) then
             call self%hist%set_vars( time=t,  inc=.True.)
             if(mod(counter, self%hist%spin_nctime)==0) then
                call self%spin_ob%get_observables( self%hist%S(:,:, self%hist%ihist_prev), &
                     self%hist%Snorm(:,self%hist%ihist_prev),self%hist%etot(self%hist%ihist_prev))
                write(msg, "(A1, 1X, I13, 4X, ES13.5, 4X, ES13.5, 4X, ES13.5)") "-", counter, t*Time_Sec, &
                     & self%spin_ob%Mst_norm_total/self%spin_ob%Snorm_total, &
                     & self%hist%etot(self%hist%ihist_prev)/self%spin_ob%nscell
                ! total : 13+4+...= 64 
                call wrtout(std_out,msg,'COLL')
                call wrtout(ab_out, msg, 'COLL')
             endif
          end if
          t=t+self%dt
       end do

       t=0.0
       counter=0
       if (iam_master) then
          call self%hist%reset(array_to_zero=.False.)
          msg="Measurement run:"
          call wrtout(std_out,msg,'COLL')
          call wrtout(ab_out, msg, 'COLL')
       end if
    endif
    if(iam_master) then
       call self%spin_ob%reset()
    endif

    do while(t<self%total_time)
       counter=counter+1
       call self%run_one_step(effpot=calculator, displacement=displacement, strain=strain, spin=spin, lwf=lwf)
       if (iam_master) then
          call self%hist%set_vars(time=t,  inc=.True.)
          call self%spin_ob%get_observables(self%hist%S(:,:, self%hist%ihist_prev), &
               self%hist%Snorm(:,self%hist%ihist_prev), self%hist%etot(self%hist%ihist_prev))
          if(modulo(counter, self%hist%spin_nctime)==0) then
             call self%spin_ncfile%write_one_step(self%hist)
             write(msg, "(A1, 1X, I13, 4X, ES13.5, 4X, ES13.5, 4X, ES13.5)") "-", counter, t*Time_Sec, &
                  & self%spin_ob%Mst_norm_total/self%spin_ob%Snorm_total, &
                  & self%hist%etot(self%hist%ihist_prev)/self%spin_ob%nscell
             call wrtout(std_out,msg,'COLL')
             call wrtout(ab_out, msg, 'COLL')
          endif
       end if
       t=t+self%dt
    enddo

    if (iam_master) then
       msg=repeat("-", 80)
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')

       write(msg, "(A27)") "Summary of spin dynamics:"
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')

       write(msg, "(A65)") "At the end of the run, the average spin at each sublattice is"
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')

       write(msg, "(6X, A10, 5X, 3A10, A11)")  'Sublattice', '<M_i>(x)', '<M_i>(y)', '<M_i>(z)', '||<M_i>||'
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')

       do i =1, self%spin_ob%nsublatt
          write(msg, "(A1, 5X, 2X, I5.4, 8X, 4F10.5)") '-', i, &
               (self%spin_ob%Mst_sub(ii,i)/self%spin_ob%nspin_sub(i)/mu_B , ii=1, 3), &
               sqrt(sum((self%spin_ob%Mst_sub(:, i)/self%spin_ob%nspin_sub(i)/mu_B)**2))
          call wrtout(std_out,msg,'COLL')
          call wrtout(ab_out, msg, 'COLL')
       end do

       call wrtout(std_out,msg_empty,'COLL')
       call wrtout(ab_out, msg_empty, 'COLL')

       write(msg, "(A1, 1X, A11, 3X, A13, 3X, A13, 3X, A13, 3X, A13 )" ) &
            "#", "Temperature", "Cv", "chi",  "BinderU4", "Mst"
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out, msg, "COLL")
       write(msg, "(2X, F11.5, 3X, ES13.5, 3X, ES13.5, 3X, E13.5, 3X, ES13.5, 3X )" ) &
            self%temperature*Ha_K , self%spin_ob%Cv, self%spin_ob%chi, &
            self%spin_ob%binderU4, self%spin_ob%Avg_Mst_norm_total/self%spin_ob%snorm_total
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out,  msg, "COLL")

       msg=repeat("=", 80)
       call wrtout(std_out,msg,'COLL')
       call wrtout(ab_out, msg, 'COLL')
    end if
  end subroutine spin_mover_t_run_time
  !!***




  !!****f* m_spin_mover/run_MvT
  !!
  !! NAME
  !! run_MvT
  !!
  !! FUNCTION
  !! run M vs Temperature
  !!
  !! INPUTS
  !! pot: potential
  !! T_start, Tend, T_nstep
  !!
  !! OUTPUT
  !!
  !! PARENTS
  !!
  !!
  !! CHILDREN
  !!
  !!
  !! SOURCE
  subroutine  run_MvT(self, pot, ncfile_prefix, displacement, strain, spin, lwf)
    class(spin_mover_t), intent(inout) :: self
    class(abstract_potential_t), intent(inout) :: pot
    real(dp), optional, intent(inout) :: displacement(:,:), strain(:,:), lwf(:), spin(:,:)
    character(fnlen), intent(inout) :: ncfile_prefix
    real(dp) :: T_start, T_end
    integer :: T_nstep
    type(spin_ncfile_t) :: spin_ncfile
    character(len=4) :: post_fname
    real(dp) :: T, T_step
    integer :: i, ii, Tfile, iostat
    character(len=90) :: msg
    character(len=4200) :: Tmsg ! to write to var T file
    character(len=150) :: iomsg
    character(fnlen) :: Tfname ! file name for output various T calculation
    real(dp), allocatable :: Tlist(:), chi_list(:), Cv_list(:), binderU4_list(:)
    real(dp), allocatable :: Mst_sub_norm_list(:, :)
    real(dp), allocatable ::  Mst_norm_total_list(:)
    if (iam_master) then
       T_start=self%params%spin_temperature_start
       T_end=self%params%spin_temperature_end
       T_nstep=self%params%spin_temperature_nstep
       Tfile=get_unit()
       Tfname = trim(ncfile_prefix)//'.varT'
       iostat=open_file(file=Tfname, unit=Tfile, iomsg=iomsg )
       T_step=(T_end-T_start)/(T_nstep-1)
       write(msg, "(A52, ES13.5, A11, ES13.5, A1)") & 
            & "Starting temperature dependent calculations. T from ", &
            & T_start*Ha_K, "K to ", T_end*Ha_K, " K."
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out, msg, "COLL")

       ABI_ALLOCATE(Tlist, (T_nstep))
       ABI_ALLOCATE(chi_list, (T_nstep))
       ABI_ALLOCATE(Cv_list, (T_nstep))
       ABI_ALLOCATE(binderU4_list, (T_nstep))
       ABI_ALLOCATE(Mst_sub_norm_list, (self%spin_ob%nsublatt, T_nstep))
       ABI_ALLOCATE( Mst_norm_total_list, (T_nstep))
    end if

    call xmpi_bcast(T_nstep, 0, comm, ierr)
    do i=1, T_nstep
       if(iam_master) then
          T=T_start+(i-1)*T_step
          msg=repeat("=", 79)
          call wrtout(std_out, msg, "COLL")
          call wrtout(ab_out, msg, "COLL")

          write(msg, "(A13, 5X, ES13.5, A3)") "Temperature: ", T*Ha_K, " K."
          call wrtout(std_out, msg, "COLL")
          call wrtout(ab_out,  msg, "COLL")

          call self%hist%reset(array_to_zero=.False.)
          ! set temperature
          ! TODO make this into a subroutine set_params
          self%params%spin_temperature=T
        endif
        call self%set_temperature(temperature=T)
        if(iam_master) then
          call self%hist%set_params(spin_nctime=self%params%spin_nctime, &
               &     spin_temperature=T)
          call self%spin_ob%reset(self%params)
          ! uncomment if then to use spin initializer at every temperature. otherwise use last temperature
          if(i==0) then
             call self%set_initial_state()
             !call self%hist%inc1()
          else
             call self%hist%inc1()
          endif

          write(post_fname, "(I4.4)") i
          call self%prepare_ncfile( self%params, &
               & trim(ncfile_prefix)//'_T'//post_fname//'_spinhist.nc')
          call spin_ncfile%write_one_step(self%hist)
       endif

       ! run in parallel
       call self%run_time(pot, displacement=displacement, strain=strain, spin=spin, lwf=lwf)

       if(iam_master) then
          call spin_ncfile%close()
          ! save observables
          Tlist(i)=T
          chi_list(i)=self%spin_ob%chi
          Cv_list(i)=self%spin_ob%Cv
          binderU4_list(i)=self%spin_ob%binderU4
          !Mst_sub_list(:,:,i)=self%spin_ob%Mst_sub(:,:)  ! not useful
          Mst_sub_norm_list(:,i)=self%spin_ob%Avg_Mst_sub_norm(:)
          Mst_norm_total_list(i)=self%spin_ob%Avg_Mst_norm_total
       endif
    end do


    if(iam_master) then
       ! write summary of MvT run
       msg=repeat("=", 79)
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out, msg, "COLL")

       write(msg, *) "Summary of various T run: "
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out, msg, "COLL")

       write(msg, "(A1, 1X, A11, 3X, A13, 3X, A13, 3X, A13, 3X, A13)" ) &
            "#", "Temperature", "Cv", "chi",  "BinderU4", "Mst"
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out,  msg, "COLL")

       do i = 1, T_nstep
          write(msg, "(2X, F11.5, 3X, ES13.5, 3X, ES13.5, 3X, E13.5, 3X, ES13.5 )" ) &
               Tlist(i)*Ha_K, Cv_list(i), chi_list(i),  binderU4_list(i), Mst_norm_total_list(i)/self%spin_ob%snorm_total
          call wrtout(std_out, msg, "COLL")
          call wrtout(ab_out, msg, "COLL")
       end do

       msg=repeat("=", 79)
       call wrtout(std_out, msg, "COLL")
       call wrtout(ab_out, msg, "COLL")


       ! write to .varT file
       write(Tmsg, "(A1, 1X, A11, 3X, A13, 3X, A13, 3X, A13, 3X, A13, 3X, *(I13, 3X) )" ) &
            "#", "Temperature (K)", "Cv (1)", "chi (1)",  "BinderU4 (1)", "Mst/Ms(1)", (ii, ii=1, self%spin_ob%nsublatt)
       call wrtout(Tfile, Tmsg, "COLL")

       do i = 1, T_nstep
          write(Tmsg, "(2X, F11.5, 3X, ES13.5, 3X, ES13.5, 3X, E13.5, 3X, ES13.5, 3X, *(ES13.5, 3X) )" ) &
               Tlist(i)*Ha_K, Cv_list(i), chi_list(i),  binderU4_list(i), Mst_norm_total_list(i)/self%spin_ob%snorm_total,&
               & (Mst_sub_norm_list(ii,i)/mu_B, ii=1, self%spin_ob%nsublatt)
          call wrtout(Tfile, Tmsg, "COLL")
       end do
       iostat= close_unit(unit=Tfile, iomsg=iomsg)

       ABI_DEALLOCATE(Tlist)
       ABI_DEALLOCATE(chi_list)
       ABI_DEALLOCATE(Cv_list)
       ABI_DEALLOCATE(binderU4_list)
       ABI_DEALLOCATE(Mst_sub_norm_list)
       ABI_DEALLOCATE( Mst_norm_total_list)

    endif
  end subroutine run_MvT
  !!***

 !!****f* m_spin_mover/current_spin
  !!
  !! NAME
  !! current_spin
  !!
  !! FUNCTION
  !! return the current spin state
  !!
  !! INPUTS
  !! 
  !!
  !! OUTPUT
  !!
  !! PARENTS
  !!
  !!
  !! CHILDREN
  !!
  !!
  !! SOURCE
  function current_spin(self) result(ret)
    class(spin_mover_t), target, intent(inout) :: self
    real(dp), pointer :: ret(:,:)
    integer :: i
    i=self%hist%findIndex(step=0)
    ret => self%hist%S(:,:,i)
  end function current_spin
!!***




  !!****f* m_spin_mover/finalize
  !!
  !! NAME
  !! finalize
  !!
  !! FUNCTION
  !! finalize spin mover.
  !!
  !! INPUTS
  !!
  !! OUTPUT
  !!
  !! NOTES
  !!   does nothing. But it's better to preserve initialize-finalize symmetry.
  !!
  !! PARENTS
  !!
  !! CHILDREN
  !!
  !! SOURCE
  subroutine finalize(self)

    class(spin_mover_t), intent(inout):: self
    if(allocated(self%gyro_ratio) ) then
       ABI_DEALLOCATE(self%gyro_ratio)
    end if

    if(allocated(self%damping) ) then
       ABI_DEALLOCATE(self%damping)
    end if

    if(allocated(self%gamma_l) ) then
       ABI_DEALLOCATE(self%gamma_l)
    end if

    if(allocated(self%H_lang_coeff) ) then
       ABI_DEALLOCATE(self%H_lang_coeff)
    end if

    if(allocated(self%ms) ) then
       ABI_DEALLOCATE(self%ms)
    end if



    if(self%method==3) then
       call self%spin_mc%finalize()
    end if

    if(allocated(self%Stmp)) then
       ABI_DEALLOCATE(self%Stmp)
    end if


    if(allocated(self%Heff_tmp)) then
       ABI_DEALLOCATE(self%Heff_tmp)
    end if

    if(allocated(self%Htmp)) then
       ABI_DEALLOCATE(self%Htmp)
    end if

    if(allocated(self%Hrotate)) then
       ABI_DEALLOCATE(self%Hrotate)
    end if

    if(allocated(self%H_lang)) then
       ABI_DEALLOCATE(self%H_lang)
    end if

    if(allocated(self%buffer)) then
       ABI_DEALLOCATE(self%buffer)
    end if


    nullify(self%supercell)
    nullify(self%params)
    call self%mps%finalize()
    call self%hist%finalize()
    call self%spin_ob%finalize()
    call self%spin_ncfile%close()
    call self%spin_ob%finalize()
  end subroutine finalize
  !!***

end module m_spin_mover
