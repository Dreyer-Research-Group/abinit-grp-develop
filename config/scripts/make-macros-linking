#!/usr/bin/env python
#
# Copyright (C) 2011-2018 ABINIT Group (Yann Pouillon)
#
# This file is part of the ABINIT software package. For license information,
# please see the COPYING file in the top-level directory of the ABINIT source
# distribution.
#
from __future__ import print_function, division, absolute_import #, unicode_literals

try:
    from ConfigParser import ConfigParser,NoOptionError
except ImportError:
    from configparser import ConfigParser,NoOptionError
from time import gmtime,strftime

import os
import re
import sys

class MyConfigParser(ConfigParser):

  def optionxform(self,option):
    return str(option)

# ---------------------------------------------------------------------------- #

#
# Subroutines
#

# Macro header
def macro_header(name,stamp):

  return """# Generated by %s on %s

#
# ABINIT fallback support for the "configure" script
#

#
# IMPORTANT NOTE
#
# This file has been automatically generated by the %s
# script. If you try to edit it, your changes will systematically be
# overwritten.
#
""" % (name,stamp,name)



# Init macro header
def macro_fallbacks(incs,libs,bins):

  # Create template
  ret = """


# ABI_FALLBACKS_PARAMS()
# ----------------------
#
# Sets all variables needed to link against fallbacks.
#
AC_DEFUN([ABI_FALLBACKS_PARAMS],[
@MACRO@
]) # ABI_FALLBACKS_PARAMS
"""

  # Init
  macro = ""

  # Set include specs
  macro += "\n  dnl Include flags\n"
  pkg_names = list(incs.keys())
  pkg_names.sort()
  for pkg in pkg_names:
    macro += "  if test \"${enable_%s}\" = \"yes\"; then\n" % (pkg)
    macro += "    lib_%s_incs=\"${fallbacks_incs}\"\n" % (pkg)
    macro += "  fi\n"

  # Set library specs
  macro += "\n  dnl Library flags\n"
  pkg_names = list(libs.keys())
  pkg_names.sort()
  for pkg in pkg_names:
    macro += "  if test \"${enable_%s}\" = \"yes\"; then\n" % (pkg)
    macro += "    lib_%s_libs='-L$(fallbacks_instdir)/lib" % \
      (pkg)
    for lib in libs[pkg]:
      macro += " -l%s" % (lib)
    macro += "'\n"
    macro += "  fi\n"

  # Set binary specs
  macro += "\n  dnl Binary command lines"
  pkg_names = list(bins.keys())
  pkg_names.sort()
  for pkg in pkg_names:
    macro += "\n  if test \"${enable_%s}\" = \"yes\"; then\n" % (pkg)
    for prog in bins[pkg]:
      prog_name = re.sub("[\.-]","_",prog).lower()
      macro += "    run_%s=\"${fallbacks_instdir}/bin/%s-abinit\"\n" % \
        (prog_name,prog)
    macro += "  else\n"
    for prog in bins[pkg]:
      prog_name = re.sub("[\.-]","_",prog).lower()
      macro += "    run_%s=\"${%s_BIN}\"\n" % (prog_name,prog_name.upper())
    macro += "  fi\n"
    for prog in bins[pkg]:
      prog_name = re.sub("[\.-]","_",prog).lower()
      macro += "  AC_SUBST(run_%s)\n" % (prog_name)

  # Transform template (the order is important)
  ret = re.sub("@MACRO@",macro,ret)

  return ret



# ---------------------------------------------------------------------------- #

#
# Main program
#

# Initial setup
my_name    = "make-macros-linking"
my_configs = {"fbak":"fallbacks/config/specs/fallbacks.conf"}
my_output  = "config/m4/auto-linking.m4"

# Check if we are in the top of the ABINIT source tree
if ( not os.path.exists("configure.ac") or
     not os.path.exists("src/98_main/abinit.F90") ):
  print("%s: You must be in the top of an ABINIT source tree." % my_name)
  print("%s: Aborting now." % my_name)
  sys.exit(1)

# Read config file(s)
for cnf_file in my_configs.values():
  if ( not os.path.exists(cnf_file) ):
    print("%s: Could not find config file (%s)." % (my_name,cnf_file))
    print("%s: Aborting now." % my_name)
    sys.exit(2)

# What time is it?
now = strftime("%Y/%m/%d %H:%M:%S +0000",gmtime())

# Init
cnf = MyConfigParser()
cnf.read(my_configs["fbak"])
abinit_fallbacks = cnf.sections()
abinit_fallbacks.sort()

bins = dict()
incs = dict()
libs = dict()

# Start writing macro
m4 = open(my_output, "wt")
m4.write(macro_header(my_name,now))

# Process fallbacks
for pkg in abinit_fallbacks:

  # Extract mandatory package information
  pkg_name = cnf.get(pkg,"name")
  pkg_desc = cnf.get(pkg,"description")
  pkg_md5s = cnf.get(pkg,"md5sum")
  pkg_urls = cnf.get(pkg,"urls").split()

  # Extract optional package information
  try:
    pkg_bins = cnf.get(pkg,"binaries").split()
  except NoOptionError:
    pkg_bins = None
  try:
    pkg_hdrs = cnf.get(pkg,"headers").split()
  except NoOptionError:
    pkg_hdrs = None
  try:
    pkg_libs = cnf.get(pkg,"libraries").split()
  except NoOptionError:
    pkg_libs = None
  try:
    pkg_mods = cnf.get(pkg,"modules").split()
  except NoOptionError:
    pkg_mods = None

  # Check whether the fallback exports C headers or modules
  if ( (not pkg_hdrs is None) or (not pkg_mods is None) ):
    incs[pkg] = "yes"

  # Check whether the fallback exports libraries
  if ( not pkg_libs is None ):
    libs[pkg] = list()
    for lib in pkg_libs:
      if ( re.match("lib.*\.a",lib) ):
        libs[pkg].append(re.sub("lib(.*)\.a","\\1",lib))
    libs[pkg].reverse()

  # Check whether the fallback exports binaries
  if ( not pkg_bins is None ):
    bins[pkg] = list()
    for prog in pkg_bins:
      bins[pkg].append(prog)

# Write macro
m4.write(macro_fallbacks(incs,libs,bins))

# Finish
m4.close()
